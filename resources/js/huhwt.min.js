/**
 * webtrees: online genealogy
 * Copyright (C) 2019 webtrees development team
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

function TreeViewHandlerMTV (tv_kenn, ged) {
    var tv = this; // Store "this" for usage within jQuery functions where "this" is not this ;-)

    this.treeview = $('#' + tv_kenn + '_in');
    this.treeHome = document.getElementById(tv_kenn + '_out').parentNode;
    this.loadingImage = $('#' + tv_kenn + '_loading');
    this.toolbox = $('#' + tv_kenn + '_tools');
    this.buttons = $('.tv_button:first', this.toolbox);
    this.zoom = 100; // in percent
    this.boxWidth = 180; // default family box width
    this.boxExpandedWidth = 250; // default expanded family box width
    this.cookieDays = 3; // lifetime of preferences memory, in days
    let elemTVout = document.getElementById(tv_kenn + '_out');
    this.ajaxDetails = elemTVout.dataset.urlDetails + '&instance=' + encodeURIComponent(tv_kenn);
    this.ajaxPersons = elemTVout.dataset.urlIndividuals + '&instance=' + encodeURIComponent(tv_kenn);
    this.ajaxCCE = elemTVout.dataset.urlCceadapter + '&instance=' + encodeURIComponent(tv_kenn);

    this.container = this.treeview.parent(); // Store the container element ("#" + tv_kenn + "_out")
    this.auto_box_width = false;
    this.updating = false;

    // Restore user preferences
    if (readCookie('compact') === 'true') {
        tv.compact(tv_kenn);
    }

    // Drag handlers for the treeview canvas
    (function () {
        let dragging = false;
        let drag_start_x;
        let drag_start_y;

        tv.treeview.on('mousedown touchstart', function (event) {
            event.preventDefault();

            let pageX = (event.type === 'touchstart') ? event.touches[0].pageX : event.pageX;
            let pageY = (event.type === 'touchstart') ? event.touches[0].pageY : event.pageY;

            drag_start_x = tv.treeview.offset().left - pageX;
            drag_start_y = tv.treeview.offset().top - pageY;
            dragging = true;
        });

        $(document).on('mousemove touchmove', function (event) {
            if (dragging) {
                event.preventDefault();

                let pageX = (event.type === 'touchmove') ? event.touches[0].pageX : event.pageX;
                let pageY = (event.type === 'touchmove') ? event.touches[0].pageY : event.pageY;

                tv.treeview.offset({
                    left: pageX + drag_start_x,
                    top: pageY + drag_start_y,
                });
            }
        });

        $(document).on('mouseup touchend', function (event) {
            if (dragging) {
                event.preventDefault();
                dragging = false;
            }
        });
    })();

    // Add click handlers to buttons
    tv.toolbox.find('#' + tv_kenn + 'bCompact').each(function (index, tvCompact) {
        tvCompact.onclick = function () {
            tv.compact();
        };
    });
    tv.toolbox.find('#' + tv_kenn + 'bClipping').each(function (index, tvClipping) {
        if (!tvClipping.classList.contains('noCCEadapter')) {
            tvClipping.onclick = function () {
                tv.CCEadapter(null, tv.treeHome);
            };
        }
    });
    tv.centerOnRoot(); // fire ajax update if needed, which call setComplete() when all is loaded
}
/**
 * Class TreeView setLoading method
 */
TreeViewHandlerMTV.prototype.setLoading = function () {
    this.treeview.css('cursor', 'wait');
    this.loadingImage.css('display', 'block');
};
/**
 * Class TreeView setComplete  method
 */
TreeViewHandlerMTV.prototype.setComplete = function () {
    this.treeview.css('cursor', 'move');
    this.loadingImage.css('display', 'none');
};

/**
 * Class TreeView getSize  method
 * Store the viewport current size
 */
TreeViewHandlerMTV.prototype.getSize = function () {
    var tv = this;
    // retrieve the current container bounding box
    var container = tv.container.parent();
    var offset = container.offset();
    tv.leftMin = offset.left;
    tv.leftMax = tv.leftMin + container.innerWidth();
    tv.topMin = offset.top;
    tv.topMax = tv.topMin + container.innerHeight();
    /*
        var frm = $("#tvTreeBorder");
        tv.treeview.css("width", frm.width());
        tv.treeview.css("height", frm.height()); */
};

/**
 * Class TreeView CCEadapter method
 * Perform ajax requests to send XREFs to cart
 */
TreeViewHandlerMTV.prototype.CCEadapter = function (button, treeHome) {
    var tv = this; // Store "this" for usage within jQuery functions where "this" is not this ;-)
    var XREF_ar = [];
    this.getSize();

    // check which td with datafld attribute are displayed
    tv.treeview.find('div[abbr]').each(function (index, el) {
        el = $(el, tv.treeview);
        XREF_ar.push(el.attr('abbr'));
    });
    // if some boxes need update, we perform an ajax request
    if (XREF_ar.length > 0) {
        tv.updating = true;
        tv.setLoading();
        jQuery.ajax({
            url: tv.ajaxCCE,
            dataType: 'json',
            data: 'xrefs=' + XREF_ar.join(';'),
            success: function (ret) {
                var _ret = ret;
                updateCCEcount(_ret, treeHome);
                return true;
                },
            complete: function () {
                tv.updating = true; // avoid an unuseful recursive call when all requested persons are loaded
                if (button) {
                    button.removeClass('tvPressed');
                }
                tv.setComplete();
                tv.updating = false;
            },
            timeout: function () {
                if (button) {
                    button.removeClass('tvPressed');
                }
                tv.updating = false;
                tv.setComplete();
            }
        });
    } else {
        if (button) {
            button.removeClass('tvPressed');
        }
        tv.setComplete();
    }
    return false;
};

/**
 * Class TreeView compact method
 */
TreeViewHandlerMTV.prototype.compact = function (tv_kenn) {
    var tv = this;
    var b = $('#' + tv_kenn + 'bCompact', tv.toolbox);
    tv.setLoading();
    if (tv.auto_box_width) {
        var w = tv.boxWidth * (tv.zoom / 100) + 'px';
        var ew = tv.boxExpandedWidth * (tv.zoom / 100) + 'px';
        tv.treeview.find('.tv_box:not(boxExpanded)', tv.treeview).css('width', w);
        tv.treeview.find('.boxExpanded', tv.treeview).css('width', ew);
        tv.auto_box_width = false;
        if (readCookie(tv_kenn + 'compact')) {
            createCookie(tv_kenn + 'compact', false, tv.cookieDays);
        }
        b.removeClass('tvPressed');
    } else {
        tv.treeview.find('.tv_box').css('width', 'auto');
        tv.auto_box_width = true;
        if (!readCookie(tv_kenn + 'compact')) {
            createCookie(tv_kenn + 'compact', true, tv.cookieDays);
        }
        if (!tv.updating) {
        //   tv.updateTree(false);
        }
        b.addClass('tvPressed');
    }
    tv.setComplete();
    return false;
};

/**
 * Class TreeView centerOnRoot method
 */
TreeViewHandlerMTV.prototype.centerOnRoot = function () {
    this.loadingImage.css('display', 'block');
    var tv = this;
    var tvc = this.container;
    var tvc_width = tvc.innerWidth() / 2;
    if (Number.isNaN(tvc_width)) {
        return false;
    }
    var tvc_height = tvc.innerHeight() / 2;
    var root_person = $('.rootPerson', this.treeview);

    var dLeft = tvc.offset().left + this.treeview.offset().left + tvc_width - root_person.offset().left - root_person.outerWidth/2;
    var dTop = tvc.offset().top + this.treeview.offset().top + tvc_height + root_person.offset().top - root_person.outerHeight/2;
    this.treeview.offset({left: dLeft, top: dTop});
    if (!this.updating) {
        // tv.updateTree(true);
        tv.setComplete();
    }
    return false;
};

/**
 * Class TreeView expandBox method
 * Called ONLY for elements which have NOT the class tv_link to avoid un-useful requests to the server
 * @param {string} box   - the person box element
 * @param {string} event - the call event
 */
TreeViewHandlerMTV.prototype.expandBox = function (_box, event) {
    var t = $(event.target);
    if (t.hasClass('tv_link')) {
        return false;
    }

    var box = $(_box, this.treeview);
    var bc = box.parent(); // bc is Box Container
    var pid = box.attr('abbr');
    var tv = this; // Store "this" for usage within jQuery functions where "this" is not this ;-)
    var expanded;
    var collapsed;

    if (bc.hasClass('detailsLoaded')) {
        collapsed = bc.find('.collapsedContent');
        expanded = bc.find('.tv_box:not(.collapsedContent)');
    } else {
        // Cache the box content as an hidden person's box in the box's parent element
        expanded = box;
        collapsed = box.clone();
        bc.append(collapsed.addClass('collapsedContent').css('display', 'none'));
        // we add a waiting image at the right side of the box
        var loading_image = this.loadingImage.find('img').clone().addClass('tv_box_loading').css('display', 'block');
        box.prepend(loading_image);
        tv.updating = true;
        tv.setLoading();
        // perform the Ajax request and load the result in the box
        box.load(tv.ajaxDetails + '&pid=' + encodeURIComponent(pid), function () {
            // If Lightbox module is active, we reinitialize it for the new links
            if (typeof CB_Init === 'function') {
                CB_Init();
            }
            box.css('width', tv.boxExpandedWidth * (tv.zoom / 100) + 'px');
            loading_image.remove();
            bc.addClass('detailsLoaded');
            tv.setComplete();
            tv.updating = false;
        });
    }
    if (box.hasClass('boxExpanded')) {
        expanded.css('display', 'none');
        collapsed.css('display', 'block');
        box.removeClass('boxExpanded');
    } else {
        expanded.css('display', 'block');
        collapsed.css('display', 'none');
        expanded.addClass('boxExpanded');
    }
    // we must ajust the draggable treeview size to its content size
    this.getSize();
    return false;
};


function updateCCEcount(XREFcnt, button) {
    let pto = typeof XREFcnt;
    switch (pto) {
        case 'object':
            showCountPop(XREFcnt, button);
            break;
        case 'number':
        default:
            break;
    }
}
function showCountPop(XREFcnt, elem_main) {
    let vCntS = XREFcnt[0];
    let vCntN = XREFcnt[1];
    let vCntStxt = XREFcnt[2];
    let vCntNtxt = XREFcnt[3];
    let elem_pop = document.getElementById('CCEpopUp');
    if (!elem_pop) {
        // let elem_main = document.getElementsByClassName('CCE_Menue')[0];
        let elem_dpop = document.createElement('div');
        elem_dpop.id = 'CCEpopUp';
        elem_dpop.classList = 'CCEpopup hidden';

        let elem_dlineS = document.createElement('div');
        elem_dlineS.className = 'pop-line lineS';
        elem_dpop.appendChild(elem_dlineS);
        let elem_dlineN = document.createElement('div');
        elem_dlineN.className = 'pop-line lineN';
        elem_dpop.appendChild(elem_dlineN);

        elem_main.appendChild(elem_dpop);

        elem_pop = document.getElementById('CCEpopUp');
    }
    let elem_dlineS = elem_pop.firstElementChild;
    elem_dlineS.textContent = vCntStxt;
    let elem_dlineN = elem_pop.lastElementChild;
    elem_dlineN.textContent = vCntNtxt;
    if (elem_pop.classList.contains('hidden'))
        elem_pop.classList.remove('hidden');
    elem_pop.style.opacity = 1;
    setTimeout(fadeOut,2400);
}
function fadeOut() {
    let elem_pop = document.getElementById('CCEpopUp');
    var op = 1;  // initial opacity
    var timer = setInterval(function () {
        if (op <= 0.1){
            clearInterval(timer);
            elem_pop.classList.add('hidden');
            elem_par = elem_pop.parentNode;
            elem_par.removeChild(elem_pop);
        }
        elem_pop.style.opacity = op;
        elem_pop.style.filter = 'alpha(opacity=' + op * 100 + ")";
        op -= op * 0.2;
    }, 100);
}


/**
 * @param {string} name
 * @param {string} value
 * @param {number} days
 */
function createCookie (name, value, days) {
    if (days) {
        var date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        document.cookie = name + '=' + value + '; expires=' + date.toGMTString() + '; path=/';
    } else {
        document.cookie = name + '=' + value + '; path=/';
    }
}
/**
 * @param   {string} name
 * @returns {string|null}
 */
function readCookie (name) {
    var name_equals = name + '=';
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) === ' ') {
            c = c.substring(1, c.length);
        }
        if (c.indexOf(name_equals) === 0) {
            return c.substring(name_equals.length, c.length);
        }
    }
    return null;
}